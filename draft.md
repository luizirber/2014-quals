---
title: Overlap graph-based sequence assembly in bioinformatics
author:
- name: Luiz Carlos Irber Jr
  affiliation: Michigan State University
  email: irberlui@msu.edu
date: August 2014
abstract: lalala
bibliography: <!-- \bibliography{bibs/qualsbib-pandoc.bib} -->
...

# Introduction

The genome sequencing purpose is to find the nucleotide sequence of
a long organic molecule (a strand of DNA, for example).

This long organic molecule is prepared for sequencing using chemical processes
to make it easier to be examined by a genome sequencer.
The genome sequencer process the molecule and generate a read,
a string of characters representing the underlying nucleotide sequence,
usually using "AGCT" (for Adenine, Guanine, Cytosine and Thiamine) as an alphabet.

Since no current technology can examine a molecule from beginning to end,
during the preparation the target molecule is replicated and broken in smaller fragments.
After processing each piece is output as a read by the sequencer,
with sizes ranging from 20 to more than 15K basepairs,
depending on the technology.
These reads need to be assembled to represent the original molecule's nucleotide sequence.

## The genome assembly problem

The genome assembly problem consists in reconstructing the original sequence
using the set of reads generated by a genome sequencer.
There are different theoretical approaches to solve the problem,
but usually in practice an approximation is returned
if the exact solution can't be achieved.

An assembler is a computer program which implements a solution to this problem,
using the set of reads as input and outputting the original sequence.

But reads are rarely perfect.
Errors occurring during the nucleotide identification can lead to
insertions, deletions or substitutions of the original sequence.
Also biological idiosyncrasies,
like highly repetitive or high GC-content regions,
can be difficult to sequence or not captured at all in the resulting reads.

These practical problems leads to suboptimal solutions...
contigs are continuous sequences of basepairs representing part or,
although rare, all the original biological sequence.

Genome sequencing technologies throughput is increasing steadily over the years
and is usually achieved by generating shorter reads.
This poses additional challenges for assemblers,
since scaling to handle millions (or even billions) of short reads
involves more than performance optimization.

# Theory

## The greedy approach

This approach was used mainly by the first assemblers for Sanger sequencing,
and it represents the genome assembly problem as a shortest string problem:
given a set of reads, find the shortest string containing all reads overlapping
each other.

The greedy method is based on finding all the overlaps between reads and
classify them using a scoring function,
based on criteria like overlap length or identity, for example.
A high scoring overlap is selected as a seed and extended
successively with other overlaps until there are no overlaps left.

Shortcomings of this approach involve:

  - Misassembly of repeats. Since repeats will extend the original sequence,
    the greedy method tends to collapse repetitive regions,
    leading to contigs shorter than they should be,
    and usually disagreeing with the original sequenced molecule.
  - Misplaced reads in contigs. Due to repetitive regions some reads might end
    in the wrong contig,
    misrepresenting the right order of the original sequence.

For bacterial genomes the results of this approach are acceptable,
since a smaller part of their genome is composed of repetitive regions and
also their genomes tend to be small.
But for eukaryotes the method produces incorrect contigs,
and since it involves multiple comparisons steps they don't scale well.

## Overlap-Layout-Consensus approaches


### Overlap Graph

  - Hamiltonian Path (NP-Hard)

### Unitig Graph

  - Transitive reduction on Overlap Graph
  - After reduction each vertex is a unitig
  - Not Hamiltonian anymore! (but still NP-Hard to find an optimal tour)

### String Graph

  [@myers2005fragment]

  - Remove contained and duplicated reads
  - Build the overlap graph
  - Map the contained reads
  - Estimate genome size (A-stats) and identify unique segments
    (label unique edges)
  - Traversal count for each edge by solving a
    minimum cost network flow problem.
  - Drop edges with zero count (false overlaps)

## De Bruijn approaches

  [@pevzner2001eulerian]
  - Eulerian path (linear time) -> Eulerian super path


# "Computational optimizations"

 - Fast overlap calculation
   * FM index
   * LCP trees
 - Implicit overlap graph (from FM index or LCP trees)
 - Error correction
   * kmer frequency
     - sga
   * unique kmers
     - remove (sga)

   * Tour bus algorithm
   * Remove tips (vertex only have one connection in one direction)

 - DB data for scaffolding
